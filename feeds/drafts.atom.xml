<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Siv Scripts - Drafts</title><link href="http://alysivji.github.io/" rel="alternate"></link><link href="http://alysivji.github.io/feeds/drafts.atom.xml" rel="self"></link><id>http://alysivji.github.io/</id><updated>2018-06-24T10:00:00-05:00</updated><entry><title>Testing 101: An Introduction</title><link href="http://alysivji.github.io/testing-101-introduction-to-testing-basics.html" rel="alternate"></link><published>2018-06-24T10:00:00-05:00</published><updated>2018-06-24T10:00:00-05:00</updated><author><name>Aly Sivji</name></author><id>tag:alysivji.github.io,2018-06-24:/testing-101-introduction-to-testing-basics.html</id><summary type="html">&lt;p&gt;[TODO make picture... of what?&lt;/p&gt;
&lt;p&gt;professor teaching&lt;/p&gt;
&lt;p&gt;blackboard with testing 101]&lt;/p&gt;
&lt;p&gt;Programming is writing code to solve problems. Software Engineering is the practice of using a &lt;strong&gt;structured process&lt;/strong&gt; to solve problems. As engineers, we want to have a codebase we can change, extend, and refactor as required. Tests provide assurances …&lt;/p&gt;</summary><content type="html">&lt;p&gt;[TODO make picture... of what?&lt;/p&gt;
&lt;p&gt;professor teaching&lt;/p&gt;
&lt;p&gt;blackboard with testing 101]&lt;/p&gt;
&lt;p&gt;Programming is writing code to solve problems. Software Engineering is the practice of using a &lt;strong&gt;structured process&lt;/strong&gt; to solve problems. As engineers, we want to have a codebase we can change, extend, and refactor as required. Tests provide assurances that program functionality does not &lt;a href="https://en.wikipedia.org/wiki/Regression_testing"&gt;regress&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Over the past year, I've spent a lot of time thinking about testing strategies and best practices that can help ensure correctness and allow for future modification. Specifically thought about &lt;em&gt;what&lt;/em&gt; to test, &lt;em&gt;how&lt;/em&gt; to test, and &lt;em&gt;when&lt;/em&gt; to test. Books, blogs, podcasts, YouTube videos, lectuers, discussions with friends and colleagues. Wanted to find the best way forward as I had an awesome opportunity at work.&lt;/p&gt;
&lt;p&gt;At my last job, I worked with a Senior Engineer to build out a microservices-based backend to replace our existing Django monolith. It was a greenfield project and we were encouraged to try new things. Spent a full month planning before writing a single line of code. I learned a lot by pulling threads and asking questions. At every architecture meeting, I was the one asking about the best way to test what we were designing.&lt;/p&gt;
&lt;p&gt;I soon realized there was no holy grail of testing. (Emporer has no clothes moment?). Like everything else in programming, it's about &lt;a href="https://en.wikipedia.org/wiki/The_Pragmatic_Programmer"&gt;being pragmatic&lt;/a&gt;. When we test we need to use tools that increase productivity and make the process so effortless that writing tests became the default way of doing things.&lt;/p&gt;
&lt;p&gt;If testing feels like a chore, programmers won't do it. This is how software quality slips. We dread going into the codebase because either there are no tests or the tests that exist are so brittle that we're forced to rewrite unit tests as we refactor code. This is not what Software Engineering is about. We want to spend more time dealing with the business logic than wrestling with our codebase.&lt;/p&gt;
&lt;p&gt;[picture of pendulum - not writing tests.... poor testing strategy with brittle tests]&lt;/p&gt;
&lt;p&gt;We need to start thinking about our testing strategy as we are architecting the system. In my opinion, this is one aspect the &lt;a href="https://en.wikipedia.org/wiki/Test-driven_development"&gt;TDD folks&lt;/a&gt; have done right. Thinking about tests improves how the system is architected as we are essentially &lt;a href="https://en.wikipedia.org/wiki/Eating_your_own_dog_food"&gt;dogfooding&lt;/a&gt; our APIs and thinking through implementations as we write code that is easy to test.&lt;/p&gt;
&lt;p&gt;This is the first in a series of posts where I am going to walk through my thoughts on testing. I'll start with the basics and then go through tools and techniques I use to write testable code.&lt;/p&gt;
&lt;p&gt;Disclaimer: My thoughts on testing are evolving as I gain more experience and exposure. I have &lt;a href="https://blog.codinghorror.com/strong-opinions-weakly-held/"&gt;strong opinions that are weakly held&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;Table of Contents&lt;/h4&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#why-test"&gt;Why Test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#types-of-tests"&gt;Types of Tests&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#unit-tests"&gt;Unit Tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#integration-tests"&gt;Integration Tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#functional--system-tests"&gt;Functional / System Tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#other-types-of-tests"&gt;Other Types of Tests&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#testing-pyramid"&gt;Testing Pyramid&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#testing-column"&gt;Testing Column&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#testing-terminology"&gt;Testing Terminology&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#what-to-test"&gt;What to Test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#when-to-test"&gt;When to Test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#testing-patterns"&gt;Testing Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#testing-framework"&gt;Testing Framework&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;

&lt;hr&gt;
&lt;h2&gt;Why Test&lt;/h2&gt;
&lt;p&gt;This was hinted at in the introduction, but it's best to spell it out.&lt;/p&gt;
&lt;p&gt;When we write code, we need to run it to ensure that it is doing what we expect it to. It's a contract we write with our code, given this you return this.&lt;/p&gt;
&lt;p&gt;There are many ways to execute code, we can: open a REPL, run a function in the terminal, refresh a webpage, etc. This feedback loop of entering inputs and comparing it to what we expect it is what testing is all about&lt;/p&gt;
&lt;p&gt;[ipcture of feedback loop. person changing code, refershing page, seeing result]&lt;/p&gt;
&lt;p&gt;As we write more code, our program becomes complex as modules, classes, and functions become intertwined. Testing our program becomes a challenge as we have to deal with lots of moving pieces.&lt;/p&gt;
&lt;p&gt;[picture of complex feedback loop]&lt;/p&gt;
&lt;p&gt;If our code change brings an unexpected result, we have to spend time tracing the issue to find the source of the bug. The feedback loop doesn't help us narrow the scope of the problem, we only know that an error has occurred somewhere.&lt;/p&gt;
&lt;p&gt;This does not take into account all the various test inputs we need to go over to ensure everything works as before. Can't just test the happy path, we also need to test the exception / error path.&lt;/p&gt;
&lt;p&gt;This is why we, as developers, write automated tests. Tests allow us go into the codebase, change it as required, and not have to worry about breaking pre-existing functionality.&lt;/p&gt;
&lt;p&gt;[benefits of automated testing from code complete pg 528-529 real 566]&lt;/p&gt;
&lt;p&gt;This does not even mention side-effect of tests influencing better software construction practices. Untestable god functions can be broken into logical units as we use concepts like dependency injection to increase code modualrity and readability.&lt;/p&gt;
&lt;p&gt;Lastly, we need to be cognizant of the fact that tests do not show the asbsence of errors. We are only guaranteeing that our program works in the ways we specify. If there is an input in the sample space we have not included, it might work, but it might also not work. This means that our tests will need to evolve as our codebase evolves.&lt;/p&gt;
&lt;h2&gt;Types of Tests&lt;/h2&gt;
&lt;p&gt;There are two main categories of testing: blackbox testing and whitebox testing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Blackbox Testing&lt;/strong&gt; refers to testing techniques in which the tester cannot see the inner workings of the item being tested.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Whitebox Testing&lt;/strong&gt; is the technique in which the tester can see the inner workings of the item being tested. As developers, we wrote the code inside the box so we can test it more thoroughly. There is still a need for blackbox testing as developers testing means blindspots could exist in the tests.&lt;/p&gt;
&lt;p&gt;There are many types of tests, which are grouped by what is being tested.&lt;/p&gt;
&lt;h3&gt;Unit Tests&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;unit test - Test a single public method or function&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;definition&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;whitebox testing&lt;/li&gt;
&lt;li&gt;what's the size of a unit? we'll come back to this later&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;give examples&lt;/p&gt;
&lt;p&gt;Regardless of your integration or system-testing strategy, you should test each unit thoroughly before you combine it with any others. If you’re writing several routines, you should test them one at a time. Routines aren’t really any easier to test individually, but they’re much easier to debug.&lt;/p&gt;
&lt;h3&gt;Integration Tests&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;integration test - many parts of the system are tested at once, tests a complete end-to-end lifecycle of an application or a portion versus testing selected components independently&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;definition&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;whitebox or blackbox&lt;/li&gt;
&lt;li&gt;different definition of integration. in microservices, it's integrating services whereas we consider each service with its own database component to be a unit&lt;/li&gt;
&lt;li&gt;how to do this?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;give examples&lt;/p&gt;
&lt;h3&gt;Functional / System Tests&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;definition&lt;/li&gt;
&lt;li&gt;more blackbox than whitebox, but definitely developers can do this&lt;/li&gt;
&lt;li&gt;going thru the UI might be a bit slow, so maybe we should have a subcutenaeous layer
give examples&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Other Types of Tests&lt;/h3&gt;
&lt;p&gt;We covered the 3 main kinds of developer testing, but there are definitely other types of testing&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;manual test - test completed by human&lt;/li&gt;
&lt;li&gt;load/scale test - impose stress on application by simulating heavy load conditions / highly concurrent load conditions&lt;/li&gt;
&lt;li&gt;infrastructure test - testing infrastructure underlying software&lt;/li&gt;
&lt;li&gt;QA test - like manual tests&lt;/li&gt;
&lt;li&gt;UAT (user acceptance testing) - human test assess implementation of software to see if it meets specifications&lt;/li&gt;
&lt;li&gt;acceptance test (http://softwaretestingfundamentals.com/acceptance-testing/)&lt;/li&gt;
&lt;li&gt;smoke test, just try something to see if it works. will give off smoke if it does not&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Testing Pyramid&lt;/h2&gt;
&lt;p&gt;https://martinfowler.com/bliki/TestPyramid.html&lt;/p&gt;
&lt;p&gt;A guide to structuring tests.&lt;/p&gt;
&lt;p&gt;The above 3 test types make up the testing pyramid. it's a guideline on how you should structure your tests. There are also other schools of thought, i.e. testing column, that might be a better way to think.&lt;/p&gt;
&lt;p&gt;Basic idea is that you should have enough tests at each level to make you comfortable with the level of testing in your system. Getting a little ahead of ourselves. Maybe come back to this in a later post.&lt;/p&gt;
&lt;h3&gt;Testing Column&lt;/h3&gt;
&lt;p&gt;episode 45 of talk python to me. as we'll see later. unit tests mean we have to mock a lot of things out. is this really the best way to proceed?&lt;/p&gt;
&lt;h2&gt;Testing Terminology&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;I love testing, but I hate writing tests.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SUT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;other testing terms, (state verficiation, other types of testing)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;What to Test&lt;/h2&gt;
&lt;p&gt;this is the art, what exactly do we want to test to ensure that everything is working as expected.&lt;/p&gt;
&lt;p&gt;here is where i expect people to be pragmatic. Want to test business logic&lt;/p&gt;
&lt;p&gt;you need to understand&lt;/p&gt;
&lt;p&gt;don't check implementation. sometimes it feels like that's what mocks are doing.&lt;/p&gt;
&lt;p&gt;thing that checks if something is working by mocking out the database&lt;/p&gt;
&lt;p&gt;why not also check if it's working with the database.&lt;/p&gt;
&lt;p&gt;the real thing we care about is the end result. if something isn't working. we're gonna have to change unit tests and integration tests. this is where we need to start thinking more about what a unit actually&lt;/p&gt;
&lt;p&gt;in microservices, a unit could be  aservice&lt;/p&gt;
&lt;h2&gt;When to Test&lt;/h2&gt;
&lt;p&gt;[writing tests something something something butterfly....] is this tdd?&lt;/p&gt;
&lt;p&gt;lot of words out there.&lt;/p&gt;
&lt;p&gt;make it sort of sound like a religion. don't like that. testing should be pragmatic. make it easier to understand instead of complicating it with all this jargon.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;talk about TDD&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;test first&lt;/li&gt;
&lt;li&gt;test last&lt;/li&gt;
&lt;li&gt;test driven&lt;/li&gt;
&lt;li&gt;dogma of both the TDD fanatics and anti-TDD heretics&lt;ul&gt;
&lt;li&gt;back in 2014, DHH of Rails fame &lt;a href="https://www.youtube.com/watch?v=9LfmrkyP81M"&gt;criticized the ideas behind TDD and software engineer&lt;/a&gt; at RailsConf&lt;/li&gt;
&lt;li&gt;&lt;a href="https://martinfowler.com/articles/is-tdd-dead/"&gt;Discussion with DHH, Fowler, and Kent Beck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;kent beck on software engineer radio 167 or something. minute 22 is when the TDD talk starts&lt;/li&gt;
&lt;li&gt;gerard meszaros on xunit test patterns, around 730 in is when the fun time starts&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tests as documentation? I dunno how much I believe about that. Sure that's not true everywhere. I learned a lot by reading pandas and requests tests.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Testing Patterns&lt;/h2&gt;
&lt;p&gt;Here we'll go over how to test as well as different metrics we can use to blah blah blah&lt;/p&gt;
&lt;p&gt;more from code complete here&lt;/p&gt;
&lt;p&gt;Arange, Act, Assert&lt;/p&gt;
&lt;p&gt;Given When Then&lt;/p&gt;
&lt;p&gt;[Go thru a few examples in pytest... look at how eric ma did this in his video
* &lt;a href="https://www.youtube.com/watch?v=yACtdj1_IxE"&gt;testing best practices for data science&lt;/a&gt;
]&lt;/p&gt;
&lt;p&gt;pg 513 boundary analysis&lt;/p&gt;
&lt;p&gt;always test boundaries. off by one error joke. https://martinfowler.com/bliki/TwoHardThings.html&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Test Coverage&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Testing Framework&lt;/h2&gt;
&lt;p&gt;Short section on my choice of testing framework. You saw me use py.test which is my favourite framework. Talk about why&lt;/p&gt;
&lt;p&gt;Principles behind it and why I like it versus unittest&lt;/p&gt;
&lt;p&gt;won't be teaching how to use it, but will be using it to do things. excellent documentation and brian's book is awesome too. maybe a short post on how to use pytest b/c i need it for my talk. figure out how to introduce it in the talk&lt;/p&gt;
&lt;p&gt;might come back to this in a later post&lt;/p&gt;
&lt;p&gt;how i use pytest. very high level. maybe come back to
&lt;em&gt; talk about factory functions with links to other things
&lt;/em&gt; parameterized functions (quick hit on that)
* go thru brian's book and make sure we cover a lot of things&lt;/p&gt;</content><category term="testing"></category></entry></feed>